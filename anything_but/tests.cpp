/*
	Type Handle to Avoid Implicit Conversions in standard C++

	Copyright(C) 2019 Dušan B. Jovanović (dbj@dbj.org)

	This program is free software : you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.If not, see < https://www.gnu.org/licenses/>.
*/

#include "dbj_nothing_but.h"
#include <iostream>
#include <cassert>

/*
 By "testing" in this context we basically mean: "does it or does it not compile"
 So we do not use any "testing framework"
 For compatibility: This is built with VS2017 15.9.X

 NOTE: Default warning level is "LEVEL 3" aka /W3

 Project settings are completely kept default as generated by Visual Studio
*/

	void test_different_types();
	void test_try_to_trick();
	void test_assignments();
	void test_compatibility();

#pragma warning( push )
#pragma warning( disable : 4189 )
// warning C4189 : unused local variable


/*
-----------------------------------------------------------------------------
utils
*/

// Show eXpression
#define SX(x) std::cout << std::boolalpha <<  "\nExpression: " << (#x) \
<< "\n\tValue: " << (x) << "\n"


namespace dbj {

	template<typename T>
	using remove_cvr_t = typename std::remove_reference_t< std::remove_cv_t<T> >;
} // dbj
/*
-----------------------------------------------------------------------------
*/

auto mover = []( auto arg_) noexcept
{
	return arg_;
};

template<typename T >
auto test_basic(void) -> dbj::util::nothing_but<T>
{
	/*
	Attention: T and dbj::remove_cvr_t<T>
	might be two different types
	do not mix them, use only one
	*/
	using TT = typename dbj::remove_cvr_t<T>;
	using NBT = dbj::util::nothing_but<TT>;

	TT value_{};

	// default ctor
	NBT nbt_a;
	NBT nbt_b(value_);
	// assignment
	nbt_a = mover( nbt_b );

	assert(!(nbt_a < nbt_b));

	// notice the use of TT
	TT & peeping_tom = nbt_b.data();

		SX(nbt_b);
	return nbt_b;
}

 void test_different_types()
{
	// fundamental types
	// no can do -- test_basic<void>();
	// no can do -- test_basic<std::nullptr_t>();
	// floating point types
	test_basic<float>();
	test_basic<double>();
	test_basic<long double>();
	// integral types
	test_basic<bool>();
	test_basic<char>();
	test_basic<signed char>();
	test_basic<unsigned char>();
	test_basic<char16_t>();
	test_basic<char32_t>();
	test_basic<wchar_t>();
	// signed integer types
	test_basic<short int>();
	test_basic<int>();
	test_basic<long int>();
	test_basic<long long int>();
	// unsigned integer types
	test_basic<unsigned short int>();
	test_basic<unsigned int>();
	test_basic<unsigned long int>();
	test_basic<unsigned long long int>();

}


/*
-----------------------------------------------------------------------------
try to trick with using two similar types
*/
void test_try_to_trick()
{
	/*
	NOTE: in here (MSVC  19.16.27027.1 for x86 )
	type of 2.3 is double
	type of float(2.3) is float
	type of 2.3f is float
	so to convince dbj::util::nothing_but<float>
	to play, please use float() c++ style cast 
	or appropriate float literal operators
	as bellow

	(no suffix) defines double
	f F defines float
	l L defines long double

	*/
	using just_float = dbj::util::nothing_but<float>;
	using just_double = dbj::util::nothing_but<double>;

	auto just_float_fun = [](just_float  jf_arg)
		-> just_float
	{ return { 2.3f };  };

	auto just_double_fun = [](just_double jd_arg) 
		-> just_double
	{ return { (2.3) }; };

	SX(typeid(2.3f).name());
	SX(typeid(float(2.3)).name());
	SX(typeid(42).name());

	// if no float() cast
	// 'argument': truncation from 'double' to 'T'
	just_float(2.3f);

	// if no float() cast 
	// 'argument': truncation from 'double' to 'T'
	just_float jf = 2.3f;
	just_float jf_aggregate = { 2.3f };

	just_double(2.3);
	just_double jd = 2.3;

	// no can do -- jf = jd;

	jf < jf;
	// no can do -- jf < jd;

	just_float_fun(jf);
	just_double_fun(jd);

}
/*
-----------------------------------------------------------------------------
*/
 void test_assignments() 
 {
	 using just_signed   = dbj::util::nothing_but<signed char>;
	 using just_unsigned = dbj::util::nothing_but<unsigned char>;

	 just_signed s;
	 just_unsigned u;

#ifndef _MSC_VER
	 typedef unsigned char uint8_t;
	 typedef signed char   int8_t;
#endif
	 // CLANG/GNUC/G++/MSVC(UCRT) default behaviour is wrong
	 // no warnings whatsoever here
	 uint8_t uc = int8_t('s') ;
	  int8_t sc =  uc;

	 s =  int8_t('s');
	 u = uint8_t('u');

	 /*
	 no can do:
	 s = 's';
	 u = 'u';
	 s = u;
	 s == u;
	 */
 }
/*
-----------------------------------------------------------------------------
*/
 void test_compatibility() 
 {
	 // complex use case
	 // must not use anything bit int[3] type

	 // keep it safe and simple
	 // on the stack and in the scope
	 int iarr[]{ 1,2,3 };

	 using arr_ref = std::reference_wrapper<int[3]>;
	 using just_arry = dbj::util::nothing_but< arr_ref >;

	 auto collector = [](just_arry  ja_) { 
		 arr_ref arf = ja_; // casting operator kicks in
		 arf.get()[0] = 42; 
		 return ja_;
	 };

	 arr_ref arf = std::ref(iarr);
	 just_arry arry(arf);

	 just_arry results = collector(arry);
	 
	 { // native arr ref solution
		 int iarr[]{ 1,2,3 };
		 using arr_ref   = int(&)[3];
		 // ERROR --> using just_arfy = dbj::util::nothing_but< arr_ref >;
	 }
 }

#pragma warning( pop )
