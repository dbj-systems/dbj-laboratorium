/*
	Type Handle to Avoid Implicit Conversions in standard C++

  Copyright 2019 Dušan B. Jovanović (dbj@dbj.org)

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

	   http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/


#include <array>
#include <vector>
#include <iostream>
#include <cassert>
#include <type_traits>

// we use C++ streams just in this short testing code
#define DBJ_NOTHING_BUT_STREAMS
#include "dbj_nothing_but.h"

/*
 By "testing" in this context we basically mean: "does it or does it not compile"
 So we do not use any "testing framework"

 Compatibility: This is built with Microsoft (R) C/C++ Optimizing Compiler Version 19.21.27702.2 for x86

 NOTE: Default warning level is "LEVEL 3" aka /W3

 Project settings are completely kept default as generated by Visual Studio 2019
*/

void test_different_types();
void test_try_to_trick();
void test_assignments();
void test_compatibility();

#pragma warning( push )
#pragma warning( disable : 4101 )
// warning C4101 : unused local variable


/*
-----------------------------------------------------------------------------
utils
*/

// Show eXpression
#define SX(x) std::cout << std::boolalpha <<  "\n Expression: " << (#x) \
<< "\n\t Value: " << (x) << "\n"


namespace dbj {

	template<typename T>
	using remove_cvr_t = typename std::remove_reference_t< std::remove_cv_t<T> >;
} // dbj
/**/
inline auto mover = [](auto arg_) noexcept
{
	return arg_;
};

// safe computing in action
// Safe SiZE
using safe_size = dbj::util::nothing_but< size_t >;
// Safe u char
using unsigned_char_type  = dbj::util::nothing_but < unsigned char >;
// safe u char buffer
using uc_buffer_type = std::vector<unsigned_char_type>;

/* safe buffer does not allow mixing singed and unsigned char's */
static uc_buffer_type uc_buffer(safe_size  sz_) noexcept
{
	// Safe u char
	return uc_buffer_type( safe_size::value_type(sz_), unsigned_char_type::value_type(0) );
};

void test_comparators() 
{
	// Safe SiZE
	using safe_size = dbj::util::nothing_but < size_t >;

	safe_size s1{ size_t(1) };
	safe_size s2{ size_t(2) };

	SX(s1 < s2);

	// long   & lng = s1;
	safe_size::value_type & sze = s1;

	sze = 23.4 ;

	float  f{ float(1.2)  };
	double d{ double(3.4)  };

	SX(f < d);
}

void test_vector_walk() {

	// Safe SiZE
	using safe_size = dbj::util::nothing_but < size_t >;

	auto buffy_ = uc_buffer( safe_size::value_type(BUFSIZ) );

	for (safe_size walker = safe_size(safe_size::value_type(0)) ;
		walker < safe_size(buffy_.size()); 
		walker++
		) {
		// since this is safe buffer of u chars 
		// we need to take care so that we
		// pass u char and notthing but u char
		buffy_[walker] = unsigned_char_type::value_type('?') ;
	}

	SX( buffy_.data() );
}

/*
basic tests on type T
*/
template<typename T >
auto test_basic(void) -> dbj::util::nothing_but<T>
{
	/*
	Attention: T and dbj::remove_cvr_t<T>
	might be two different types
	do not mix them, use only one
	*/
	using TT = typename dbj::remove_cvr_t<T>;
	using NBT = dbj::util::nothing_but<TT>;

	TT value_{};

	// default ctor
	NBT nbt_a;
	NBT nbt_b(value_);
	// assignment
	nbt_a = mover(nbt_b);

	assert(!(nbt_a < nbt_b));

	// compare wrapped up to native T
	SX(nbt_a < nbt_b);
	SX(nbt_a == nbt_b);

	// notice the use of TT
	TT& peeping_tom = nbt_b.data();

	SX(nbt_b);
	return nbt_b;
}

void test_different_types()
{
	// fundamental types
	// no can do -- test_basic<void>();
	// no can do -- test_basic<std::nullptr_t>();
	// floating point types
	test_basic<float>();
	test_basic<double>();
	test_basic<long double>();
	// integral types
	test_basic<bool>();
	test_basic<char>();
	test_basic<signed char>();
	test_basic<unsigned char>();
	test_basic<char16_t>();
	test_basic<char32_t>();
	test_basic<wchar_t>();
	// signed integer types
	test_basic<short int>();
	test_basic<int>();
	test_basic<long int>();
	test_basic<long long int>();
	// unsigned integer types
	test_basic<unsigned short int>();
	test_basic<unsigned int>();
	test_basic<unsigned long int>();
	test_basic<unsigned long long int>();

}


/*
-----------------------------------------------------------------------------
try to trick with using two similar types
*/
void test_try_to_trick()
{
	/*
	NOTE: in here (MSVC  19.16.27027.1 for x86 )
	type of 2.3 is double
	type of float(2.3) is float
	type of 2.3f is float
	so to convince dbj::util::nothing_but<float>
	to play, please use float() c++ style cast
	or appropriate float literal operators
	as bellow

	(no suffix) defines double
	f F defines float
	l L defines long double

	*/
	using just_float = dbj::util::nothing_but<float>;
	using just_double = dbj::util::nothing_but<double>;

	auto just_float_fun = [](just_float  jf_arg)
		-> just_float
	{ return { 2.3f };  };

	auto just_double_fun = [](just_double jd_arg)
		-> just_double
	{ return { (2.3) }; };

	SX(typeid(2.3f).name());
	SX(typeid(float(2.3)).name());
	SX(typeid(42).name());

	// if no float() cast
	// 'argument': truncation from 'double' to 'T'
	just_float(2.3f);

	// if no float() cast 
	// 'argument': truncation from 'double' to 'T'
	just_float jf = 2.3f;
	just_float jf_aggregate = { 2.3f };

	just_double(2.3);
	just_double jd = 2.3;

	// no can do -- jf = jd;

	jf < jf;
	// no can do -- jf < jd;

	just_float_fun(jf);
	just_double_fun(jd);

}
/*
-----------------------------------------------------------------------------
*/
void test_assignments()
{
	using just_signed = dbj::util::nothing_but<signed char>;
	using just_unsigned = dbj::util::nothing_but<unsigned char>;

	just_signed s;
	just_unsigned u;

#ifndef _MSC_VER
	typedef unsigned char uint8_t;
	typedef signed char   int8_t;
#endif
	// CLANG/GNUC/G++/MSVC(UCRT) default behaviour is wrong
	// no warnings whatsoever here
	uint8_t uc = int8_t('s');
	int8_t sc = uc;

	s = int8_t('s');
	u = uint8_t('u');

	/*
	no can do:
	s = 's';
	u = 'u';
	s = u;
	s == u;
	*/
}
/*
-----------------------------------------------------------------------------
*/
template<typename T>
auto native_array_filler(T(&sarr_arg)[3])->T(&)[3]
{
	typedef T nb_t;
	typedef typename nb_t::value_type VT;

	sarr_arg[0] = nb_t(VT('9'));
	sarr_arg[1] = nb_t(VT('8'));
	sarr_arg[2] = nb_t(VT('7'));

	return sarr_arg;
};

template<typename T>
auto native_array_filler(T* (&sarr_arg)[3])->T* (&)[3]
{
	typedef T nb_t;
	typedef typename nb_t::value_type VT;

	sarr_arg[0] = &nb_t(VT('X'));
	sarr_arg[1] = &nb_t(VT('Y'));
	sarr_arg[2] = &nb_t(VT('Z'));

	return sarr_arg;
};

void test_compatibility()
{
	auto filler = [](auto sarr_arg)
	{
		using container = decltype(sarr_arg);
		using nothing_but = typename container::value_type;
		using v_type = typename nothing_but::value_type;

		sarr_arg[0] = nothing_but(v_type('A'));
		sarr_arg[1] = nothing_but(v_type('B'));
		sarr_arg[2] = nothing_but(v_type('C'));

		return sarr_arg;
	};

	auto display = [](auto arg_)
	{
		if constexpr (false == std::is_pointer< decltype(arg_[0]) >::value) {
			wprintf(L"\n\n%S\n\n{ %c %c %c }\n\n",
				typeid(arg_).name(),
				arg_[0].data(),
				arg_[1].data(),
				arg_[2].data()
			);
		}
		else {
			wprintf(L"\n\n%S\n\n{ %c %c %c }\n\n",
				typeid(arg_).name(),
				(arg_[0])->data(),
				(arg_[1])->data(),
				(arg_[2])->data()
			);
		}
	};

	using just_signed = dbj::util::nothing_but<signed char>;
	using just_unsigned = dbj::util::nothing_but<unsigned char>;

	// nothing happens implicitly in the world of nothing_but<T>
	just_signed	sarr[3];
	just_unsigned	uarr[3];

	display(native_array_filler(sarr));
	display(native_array_filler(uarr));

	just_signed* sparr[3];
	just_unsigned* uparr[3];

	//display(native_array_filler(sparr));
	// display(native_array_filler(uparr));

	// std::array perusal
	{
		std::vector<just_signed>	std_vec(3);
		std::array<just_signed, 3>	std_arr;

		display(filler(std_arr));
		display(filler(std_vec));
	}
}

#pragma warning( pop )
